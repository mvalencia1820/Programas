/*
 * GLCD.c
 *
 *  Created on: ago 18, 2014
 *      Author: Mart
 */
#include "sys_common.h"
#include "gio.h"			// Necesaria para controlar los gioPORTA
#include "het.h"
#include "math.h"
#include "GLCD.h"

// Instrucciones de Enable
/*
#define high_Enable  	gioSetBit(gioPORTA,4,1)		//E
#define low_Enable   	gioSetBit(gioPORTA,4,0)		//E*/
#define high_Enable    		gioSetBit(hetPORT1,28,1)		//Enable
#define low_Enable     		gioSetBit(hetPORT1,28,0)		//Enable
// Instrucciones de CS1
#define high_CS1  		gioSetBit(gioPORTA,1,1)		//CS1
#define low_CS1   		gioSetBit(gioPORTA,1,0)		//CS1
// Instrucciones de CS2
#define high_CS2  		gioSetBit(gioPORTA,0,1)		//CS2
#define low_CS2   		gioSetBit(gioPORTA,0,0)		//CS2
// Instrucciones de DI
#define high_DI  		gioSetBit(hetPORT1,24,1)		//DI
#define low_DI   		gioSetBit(hetPORT1,24,0)		//DI

// Datos


struct
{
   int left[512];
   int right[512];
} displayData;

/////////////////////////////////////////////////////////////////////////
/*
const int image[]=
{

0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,


0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,


0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x3F,0x3F,0x3F,0xBF,0xFF,0xFF,0xFF,0x27,0x23,0x23,0x23,0x23,0xA3,0xE3,0xFB,0xFF,
0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,








0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xCF,0xCF,0x8F,
0x0F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,0x1F,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x3C,0x3C,0x3C,
0xFC,0xFC,0xFE,0x7F,0x0F,0x03,0x00,0x00,0x00,0x00,0xE0,0xFE,0x3F,0x3F,0x3F,0x3C,
0x3C,0x3C,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x1F,0x1F,
0x3F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,






0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFE,0xFE,0xF8,0xF0,0xE0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xC0,0xE0,
0xE0,0xE0,0xE0,0xF0,0xE0,0xE0,0xE0,0xC0,0xC0,0x80,0x00,0x00,0x00,0x00,0x78,0x7E,
0xFF,0xFB,0xF8,0xF8,0xF8,0xF8,0xF8,0xF8,0xFC,0xFF,0xFF,0xFB,0xF8,0x78,0x18,0x00,
0x00,0x00,0x80,0x80,0x80,0xC0,0xC0,0xC0,0xC0,0xE0,0xE0,0xE0,0xE0,0xF0,0xF0,0xF0,
0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,













0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC,0xF8,0xF0,0xF0,0xE0,
0xE0,0xC0,0xC0,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0xFC,0xFE,
0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,






0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,

0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x7F

};



const int image1[]=
{

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x19,0x09,0x0B,0x0F,0x3F,0xFF,0xFF,0xFC,
0xF4,0xC4,0x04,0x84,0xCC,0x4C,0x6C,0x38,0x18,0x38,0x78,0xE8,0xCC,0x84,0xE6,0x32,
0x12,0x12,0x13,0x31,0x21,0x21,0x61,0x61,0x21,0x11,0x11,0x09,0x09,0x09,0x09,0x09,
0x09,0x1B,0x12,0x12,0x12,0x16,0x34,0x2C,0x28,0x69,0x5F,0xFF,0xFF,0xFF,0xFE,0xF3,
0xE0,0xC0,0x00,0x00,0x00,0x00,0x01,0x03,0x06,0x0C,0x08,0x18,0x30,0x60,0xC0,0x80,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0xC0,0x70,0x18,0x0C,0x06,0x03,0x01,0x01,0x03,0x02,0x06,0xE7,0xFF,
0xFF,0x7F,0x3E,0x19,0x0C,0x06,0x02,0x03,0x01,0x01,0xE1,0x39,0x0F,0x01,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x03,0x07,
0x07,0x0B,0xDF,0xFE,0xF8,0xF0,0xE0,0xC0,0x80,0x00,0x00,0x00,0x80,0x00,0x20,0xE3,
0xBE,0xFC,0x70,0xE0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,
0xF0,0x9C,0xE7,0x61,0x00,0x00,0x00,0x00,0x00,0x80,0xE0,0xF8,0xFC,0xEE,0xFB,0x1D,
0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0xF0,0xC8,0x78,
0xF0,0x70,0xE2,0xCE,0x0C,0x38,0xF8,0xC0,0x80,0x86,0xBC,0xF8,0xC0,0x00,0x18,0xF0,
0xE0,0xC2,0x8E,0xFB,0xFF,0xF7,0x9F,0xBF,0xBF,0xFF,0xF0,0xE0,0xC1,0x9F,0xF0,0xC0,
0xCF,0xFF,0x0F,0x1D,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,
0x3E,0xF3,0x00,0x00,0x00,0xBC,0xFF,0x80,0xFC,0xFF,0x87,0x8F,0x83,0xFF,0xC0,0x40,
0x40,0xC0,0x9E,0xFF,0x00,0x00,0xF0,0xE0,0x00,0xE0,0xB8,0xE0,0x80,0x1C,0xFD,0xC7,
0xFC,0xF8,0xFF,0xFC,0xFB,0xFF,0xFE,0xFC,0xF8,0xF0,0xE0,0xC0,0x00,0x01,0x0F,0xFF,
0x1F,0x3E,0xF2,0xC3,0x07,0x1F,0x39,0xFF,0xE3,0x0E,0xB8,0xF1,0xFF,0xFF,0x0C,0x04,
0x07,0xE3,0xB1,0x19,0x0D,0x86,0x82,0xC0,0x60,0x21,0x11,0x13,0x03,0x07,0x8F,0x1F,
0x33,0x67,0xDF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1F,0x0F,0x03,
0x7E,0xFF,0x9C,0xF0,0x30,0x1E,0x8F,0xF7,0x1F,0x03,0x00,0xE0,0x3C,0x07,0x00,0x00,
0xE0,0x38,0x0C,0x01,0x01,0xE3,0x86,0x0F,0x1F,0x7F,0xFF,0xFF,0xFF,0xBE,0x7F,0xDF,
0x7B,0x6F,0xDE,0x10,0x81,0x83,0x8F,0x8D,0x83,0x87,0x8C,0x81,0x03,0x07,0x0C,0x0F,
0x18,0x00,0x00,0x01,0x00,0x18,0x0C,0x06,0x07,0x03,0x03,0x03,0x1F,0x33,0xEB,0xDA,
0x92,0x92,0x13,0x16,0x1F,0x09,0x18,0x10,0x30,0x68,0x4C,0x46,0x42,0x63,0x61,0x70,
0x58,0x08,0x01,0x7F,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x03,0x07,0x01,0x07,0x0C,0x0F,0x78,0x70,0x30,0xE0,0x7F,0x30,0xE0,0xC0,0xF7,
0xDD,0x98,0x88,0x88,0x8F,0xC5,0x44,0x44,0x44,0x0C,0x09,0x87,0xFF,0xFF,0xFE,0xFC,
0xF8,0x70,0xE6,0xC7,0x87,0x83,0x01,0x01,0x01,0x01,0x01,0x01,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF0,0xF8,0xFC,0xFE,0x0F,0x03,
0x01,0x07,0x3F,0xFF,0xFF,0xFE,0xFE,0xFE,0xF8,0xF8,0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,
0xF0,0xF8,0xF8,0xF8,0x7F,0xFE,0x7E,0xFE,0xFC,0xF8,0xE0,0xC0,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,


0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x70,0xDE,0xE3,0xF8,0xFF,0x7F,0xFF,0x7F,
0x3F,0x7F,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x03,
0x00,0x00,0x00,0x01,0x07,0x0F,0xFF,0x3F,0x7F,0xFF,0xF1,0x3B,0x3B,0x1B,0x1F,0x1A,
0x1A,0x1A,0x1A,0x1A,0xFB,0xF9,0xFD,0x7F,0x7F,0x3F,0x1F,0x8F,0xFF,0x01,0x00,0x00,
0x00,0x00,0x00,0xFF,0x7F,0x7F,0x7F,0xF7,0xEF,0xEF,0xDF,0xCF,0xCF,0xC7,0xC3,0xC1,
0xC0,0xE0,0xE0,0xE0,0xF0,0x73,0xFE,0x38,0x03,0x0F,0x7F,0x7F,0x7F,0x3E,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,


0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xE0,0xF0,0xF8,0xCC,0x07,0x01,0x00,0x0F,0x8F,0xF7,0xF8,0xFE,0x17,0x0F,
0x1E,0x1E,0x1C,0x1C,0x39,0x3B,0x3B,0x3B,0x3B,0x1B,0x1D,0x1F,0x0F,0x0F,0xFF,0x03,
0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0xFE,0x7F,0xFF,0xCF,0xCF,0xB8,0xE0,0x00,0x00,
0x00,0xC0,0x78,0x8F,0xC7,0xCF,0xEF,0xFF,0x7E,0xFA,0xFE,0xFF,0x7F,0x00,0x00,0x00,
0x00,0x00,0xF0,0x1F,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x04,0x02,0x03,0x00,0x0E,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
*/


/////////////////////////////////////////////////////////////////////////
//// Defines a 5x7 font
/////////////////////////////////////////////////////////////////////////
uint8 FONT[51][5] ={ 0x00, 0x00, 0x00, 0x00, 0x00, // SPACE
                         0x00, 0x00, 0x5F, 0x00, 0x00, // !
                         0x00, 0x03, 0x00, 0x03, 0x00, // "
                         0x14, 0x3E, 0x14, 0x3E, 0x14, // #
                         0x24, 0x2A, 0x7F, 0x2A, 0x12, // $
                         0x43, 0x33, 0x08, 0x66, 0x61, // %
                         0x36, 0x49, 0x55, 0x22, 0x50, // &
                         0x00, 0x05, 0x03, 0x00, 0x00, // '
                         0x00, 0x1C, 0x22, 0x41, 0x00, // (
                         0x00, 0x41, 0x22, 0x1C, 0x00, // )
                         0x14, 0x08, 0x3E, 0x08, 0x14, // *
                         0x08, 0x08, 0x3E, 0x08, 0x08, // +
                         0x00, 0x50, 0x30, 0x00, 0x00, // ,
                         0x08, 0x08, 0x08, 0x08, 0x08, // -
                         0x00, 0x60, 0x60, 0x00, 0x00, // .
                         0x20, 0x10, 0x08, 0x04, 0x02, // /
                         0x3E, 0x51, 0x49, 0x45, 0x3E, // 0
                         0x00, 0x04, 0x02, 0x7F, 0x00, // 1
                         0x42, 0x61, 0x51, 0x49, 0x46, // 2
                         0x22, 0x41, 0x49, 0x49, 0x36, // 3
                         0x18, 0x14, 0x12, 0x7F, 0x10, // 4
                         0x27, 0x45, 0x45, 0x45, 0x39, // 5
                         0x3E, 0x49, 0x49, 0x49, 0x32, // 6
                         0x01, 0x01, 0x71, 0x09, 0x07, // 7
                         0x36, 0x49, 0x49, 0x49, 0x36, // 8
                         0x26, 0x49, 0x49, 0x49, 0x3E, // 9
                         0x00, 0x36, 0x36, 0x00, 0x00, // :
                         0x00, 0x56, 0x36, 0x00, 0x00, // ;
                         0x08, 0x14, 0x22, 0x41, 0x00, // <
                         0x14, 0x14, 0x14, 0x14, 0x14, // =
                         0x00, 0x41, 0x22, 0x14, 0x08, // >
                         0x02, 0x01, 0x51, 0x09, 0x06, // ?
                         0x3E, 0x41, 0x59, 0x55, 0x5E, // @
                         0x7E, 0x09, 0x09, 0x09, 0x7E, // A
                         0x7F, 0x49, 0x49, 0x49, 0x36, // B
                         0x3E, 0x41, 0x41, 0x41, 0x22, // C
                         0x7F, 0x41, 0x41, 0x41, 0x3E, // D
                         0x7F, 0x49, 0x49, 0x49, 0x41, // E
                         0x7F, 0x09, 0x09, 0x09, 0x01, // F
                         0x3E, 0x41, 0x41, 0x49, 0x3A, // G
                         0x7F, 0x08, 0x08, 0x08, 0x7F, // H
                         0x00, 0x41, 0x7F, 0x41, 0x00, // I
                         0x30, 0x40, 0x40, 0x40, 0x3F, // J
                         0x7F, 0x08, 0x14, 0x22, 0x41, // K
                         0x7F, 0x40, 0x40, 0x40, 0x40, // L
                         0x7F, 0x02, 0x0C, 0x02, 0x7F, // M
                         0x7F, 0x02, 0x04, 0x08, 0x7F, // N
                         0x3E, 0x41, 0x41, 0x41, 0x3E, // O
                         0x7F, 0x09, 0x09, 0x09, 0x06, // P
                         0x1E, 0x21, 0x21, 0x21, 0x5E, // Q
                         0x7F, 0x09, 0x09, 0x09, 0x76};// R

uint8 FONT2[44][5]={ 0x26, 0x49, 0x49, 0x49, 0x32, // S
                         0x01, 0x01, 0x7F, 0x01, 0x01, // T
                         0x3F, 0x40, 0x40, 0x40, 0x3F, // U
                         0x1F, 0x20, 0x40, 0x20, 0x1F, // V
                         0x7F, 0x20, 0x10, 0x20, 0x7F, // W
                         0x41, 0x22, 0x1C, 0x22, 0x41, // X
                         0x07, 0x08, 0x70, 0x08, 0x07, // Y
                         0x61, 0x51, 0x49, 0x45, 0x43, // Z
                         0x00, 0x7F, 0x41, 0x00, 0x00, // [
                         0x02, 0x04, 0x08, 0x10, 0x20, //
                         0x00, 0x00, 0x41, 0x7F, 0x00, // ]
                         0x04, 0x02, 0x01, 0x02, 0x04, // ^
                         0x40, 0x40, 0x40, 0x40, 0x40, // _
                         0x00, 0x01, 0x02, 0x04, 0x00, // `
                         0x20, 0x54, 0x54, 0x54, 0x78, // a
                         0x7F, 0x44, 0x44, 0x44, 0x38, // b
                         0x38, 0x44, 0x44, 0x44, 0x44, // c
                         0x38, 0x44, 0x44, 0x44, 0x7F, // d
                         0x38, 0x54, 0x54, 0x54, 0x18, // e
                         0x04, 0x04, 0x7E, 0x05, 0x05, // f
                         0x08, 0x54, 0x54, 0x54, 0x3C, // g
                         0x7F, 0x08, 0x04, 0x04, 0x78, // h
                         0x00, 0x44, 0x7D, 0x40, 0x00, // i
                         0x20, 0x40, 0x44, 0x3D, 0x00, // j
                         0x7F, 0x10, 0x28, 0x44, 0x00, // k
                         0x00, 0x41, 0x7F, 0x40, 0x00, // l
                         0x7C, 0x04, 0x78, 0x04, 0x78, // m
                         0x7C, 0x08, 0x04, 0x04, 0x78, // n
                         0x38, 0x44, 0x44, 0x44, 0x38, // o
                         0x7C, 0x14, 0x14, 0x14, 0x08, // p
                         0x08, 0x14, 0x14, 0x14, 0x7C, // q
                         0x00, 0x7C, 0x08, 0x04, 0x04, // r
                         0x48, 0x54, 0x54, 0x54, 0x20, // s
                         0x04, 0x04, 0x3F, 0x44, 0x44, // t
                         0x3C, 0x40, 0x40, 0x20, 0x7C, // u
                         0x1C, 0x20, 0x40, 0x20, 0x1C, // v
                         0x3C, 0x40, 0x30, 0x40, 0x3C, // w
                         0x44, 0x28, 0x10, 0x28, 0x44, // x
                         0x0C, 0x50, 0x50, 0x50, 0x3C, // y
                         0x44, 0x64, 0x54, 0x4C, 0x44, // z
                         0x00, 0x08, 0x36, 0x41, 0x41, // {
                         0x00, 0x00, 0x7F, 0x00, 0x00, // |
                         0x41, 0x41, 0x36, 0x08, 0x00, // }
                         0x02, 0x01, 0x02, 0x04, 0x02};// ~
/////////////////////////////////////////////////////////////////////////

/*
const int image_xy[]=
{
 0x40 , 0x20,
 0xFF , 0xFF , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03,
 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0xC3 , 0xE3,
 0x63 , 0x63 , 0x63 , 0x63 , 0xC3 , 0x83 , 0x03 , 0x03,
 0x03 , 0x03 , 0x03 , 0x03 , 0x83 , 0xC3 , 0x63 , 0x33,
 0x33 , 0x33 , 0x63 , 0xC3 , 0x03 , 0x03 , 0x03 , 0x03,
 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03,
 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03,
 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0x03 , 0xFF , 0xFF,
 0xFF , 0xFF , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x07 , 0x0F,
 0x0C , 0x0E , 0x0F , 0x0E , 0x0C , 0x09 , 0x0F , 0x00,
 0x80 , 0x80 , 0x80 , 0x03 , 0x0F , 0x0C , 0x08 , 0x0F,
 0x0F , 0x04 , 0x0C , 0x0F , 0x0F , 0x00 , 0x00 , 0x00,
 0x00 , 0x00 , 0xF0 , 0xF8 , 0xC0 , 0xC0 , 0xFC , 0xF0,
 0x00 , 0x00 , 0x00 , 0xD0 , 0xB0 , 0x00 , 0x00 , 0xFC,
 0xFE , 0xF8 , 0x00 , 0x00 , 0x00 , 0x00 , 0xFF , 0xFF,
 0xFF , 0xFF , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00,
 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x03,
 0x0F , 0x1E , 0x3C , 0x38 , 0x70 , 0x70 , 0xE0 , 0xE0,
 0xE1 , 0xC3 , 0xC7 , 0xC0 , 0xC0 , 0x80 , 0x80 , 0x80,
 0x80 , 0xF8 , 0xFC , 0x0E , 0x03 , 0x00 , 0x00 , 0x00,
 0x00 , 0x00 , 0x0F , 0x07 , 0x00 , 0x00 , 0x07 , 0x03,
 0x02 , 0x00 , 0x00 , 0x0F , 0x1F , 0x00 , 0x00 , 0x00,
 0x73 , 0x71 , 0x40 , 0x00 , 0x00 , 0x00 , 0xFF , 0xFF,
 0xFF , 0xFF , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC1 , 0xC1 , 0xC1 , 0xC1 , 0xC1,
 0xC1 , 0xC1 , 0xC1 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0,
 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xC0 , 0xFF , 0xFF
};*/
/******************/
/* 256 Bytes */
/*  End of LCD Pattern  */


void output_dato(int variable)
{
	if(((variable & (1<<0)) != 0))
	 gioSetBit(hetPORT1,16,1);
	else
	 gioSetBit(hetPORT1,16,0);


	if(((variable & (1<<1)) != 0))
	 gioSetBit(hetPORT1,14,1);
	else
	 gioSetBit(hetPORT1,14,0);

	if(((variable & (1<<2)) != 0))
	 gioSetBit(hetPORT1,12,1);
	else
	 gioSetBit(hetPORT1,12,0);

	if(((variable & (1<<3)) != 0))
	 gioSetBit(hetPORT1,10,1);
	else
	 gioSetBit(hetPORT1,10,0);

	if(((variable & (1<<4)) != 0))
	 gioSetBit(hetPORT1,6,1);
	else
	 gioSetBit(hetPORT1,6,0);

	if(((variable & (1<<5)) != 0))
	 gioSetBit(hetPORT1,4,1);
	else
	 gioSetBit(hetPORT1,4,0);


	if(((variable & (1<<6)) != 0))
	 gioSetBit(hetPORT1,2,1);
	else
	 gioSetBit(hetPORT1,2,0);

	if(((variable & (1<<7)) != 0))
	 gioSetBit(hetPORT1,0,1);
	else
	 gioSetBit(hetPORT1,0,0);
}


// Purpose:       Initialize the LCD.
//                Call before using any other LCD function.
// Inputs:        OFF - Turns the LCD off
//                ON  - Turns the LCD on
void glcd_init(int mode)
{

   low_Enable;
   low_CS1;
   low_CS2;
   low_DI;


   glcd_writeByte(GLCD_LEFT,  0xC0);    // Specify first RAM line at the top
   glcd_writeByte(GLCD_RIGHT, 0xC0);    //   of the screen
   glcd_writeByte(GLCD_LEFT,  0x40);    // Set the column address to 0
   glcd_writeByte(GLCD_RIGHT, 0x40);
   glcd_writeByte(GLCD_LEFT,  0xB8);    // Set the page address to 0
   glcd_writeByte(GLCD_RIGHT, 0xB8);

   if(mode == ON)
   {
      glcd_writeByte(GLCD_LEFT,  0x3F); // Turn the display on
      glcd_writeByte(GLCD_RIGHT, 0x3F);
   }
   else
   {
      glcd_writeByte(GLCD_LEFT,  0x3E); // Turn the display off
      glcd_writeByte(GLCD_RIGHT, 0x3E);
   }

   glcd_fillScreen(OFF);                // Clear the display


   glcd_update();

}


// Purpose:    Update the LCD with data from the display arrays
void glcd_update()
{
   int i, j;
   int *p1, *p2;

   p1 = displayData.left;
   p2 = displayData.right;

   // Loop through the vertical pages
   for(i = 0; i < 8; ++i)
   {


	   low_DI;

      glcd_writeByte(GLCD_LEFT, 0x40);          // Set horizontal address to 0
      glcd_writeByte(GLCD_RIGHT, 0x40);
      glcd_writeByte(GLCD_LEFT, i | 0xB8);      // Set page address
      glcd_writeByte(GLCD_RIGHT, i | 0xB8);


      high_DI;


      // Loop through the horizontal sections
      for(j = 0; j < 64; ++j)
      {
         glcd_writeByte(GLCD_LEFT, *p1++);      // Turn pixels on or off
         glcd_writeByte(GLCD_RIGHT, *p2++);     // Turn pixels on or off
      }
   }
}


//****************************************************************************//
// Purpose:       Draw a line on a graphic LCD using Bresenham's              //
//                line drawing algorithm                                      //
// Inputs:        (x1, y1) - the start coordinate                             //
//                (x2, y2) - the end coordinate                               //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel()                                                //
//****************************************************************************//
void glcd_line(int x1, int y1, int x2, int y2, int color)
{
   signed int  x, y, addx, addy, dx, dy;
   signed long P;
   int i;
   dx = abs((signed int)(x2 - x1));
   dy = abs((signed int)(y2 - y1));
   x = x1;
   y = y1;

   if(x1 > x2)
      addx = -1;
   else
      addx = 1;
   if(y1 > y2)
      addy = -1;
   else
      addy = 1;

   if(dx >= dy)
   {
      P = 2*dy - dx;

      for(i=0; i<=dx; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dy;
            x += addx;
         }
         else
         {
            P += 2*dy - 2*dx;
            x += addx;
            y += addy;
         }
      }
   }
   else
   {
      P = 2*dx - dy;

      for(i=0; i<=dy; ++i)
      {
         glcd_pixel(x, y, color);

         if(P < 0)
         {
            P += 2*dx;
            y += addy;
         }
         else
         {
            P += 2*dx - 2*dy;
            x += addx;
            y += addy;
         }
      }
   }
}

//****************************************************************************//
// Purpose:       Draw a circle on a graphic LCD                              //
// Inputs:        (x,y) - the center of the circle                            //
//                radius - the radius of the circle                           //
//                fill - YES or NO                                            //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel(), glcd_line()                                   //
//****************************************************************************//
void glcd_circle(int x, int y, int radius, int fill, int color)
{
   signed int a, b, P;
   a = 0;
   b = radius;
   P = 1 - radius;

   do
   {
      if(fill)
      {
         glcd_line(x-a, y+b, x+a, y+b, color);
         glcd_line(x-a, y-b, x+a, y-b, color);
         glcd_line(x-b, y+a, x+b, y+a, color);
         glcd_line(x-b, y-a, x+b, y-a, color);
      }
      else
      {
         glcd_pixel(a+x, b+y, color);
         glcd_pixel(b+x, a+y, color);
         glcd_pixel(x-a, b+y, color);
         glcd_pixel(x-b, a+y, color);
         glcd_pixel(b+x, y-a, color);
         glcd_pixel(a+x, y-b, color);
         glcd_pixel(x-a, y-b, color);
         glcd_pixel(x-b, y-a, color);
      }

      if(P < 0)
         P+= 3 + 2*a++;
      else
         P+= 5 + 2*(a++ - b--);
    } while(a <= b);
}

// Purpose:    Turn a pixel on a graphic LCD on or off
// Inputs:     1) x - the x coordinate of the pixel
//             2) y - the y coordinate of the pixel
//             3) color - ON or OFF
void glcd_pixel(int x, int y, int color)
{
   int* p;
   int temp;
   temp =  y/8;
   temp *= 64;
   temp += x;

   if(x > 63)
   {
      p = displayData.right + temp - 64;
   }
   else
   {
      p = displayData.left + temp;
   }

   if(color)					// funciona muy bien,
	   	   	   	   	   	   	   // esta etapa no presenta problemas
      *p|= (1<<y%8);
   else
      *p &= ~(1<<y%8);

}
//****************************************************************************//
// Purpose:       Draw a segment of a circle on a graphic LCD                 //
// Inputs:        (x,y) - The center of the circle                            //
//                radius - The radius of the circle                           //
//                angle_start - Start point angle of segment of circle        //
//                angle_end - End point angle of segment of circle            //
//                                                                            //
// Example:       (angle_start = 0 & angle_end = 360 draws a normal circle)   //
//                (angle_start = 0 & angle_end = 180 draws half circle (arc) )//
//                                                                            //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel(), <math.h>                                      //
//****************************************************************************//
void glcd_circle_seg(int x, int y, int radius, int angle_start, int angle_end, int color)
{
   int   x_round, y_round;
   float angle;
   #define DEGREE 2*3.14159265/360

   for (angle = (float)angle_start; angle <= angle_end; angle += .9)
   {
      x_round = (sin (angle * DEGREE) * radius);
      y_round = (cos (angle * DEGREE) * radius);
      glcd_pixel(x + x_round, y + y_round, color);
   }
}

// Purpose:    Fill the LCD screen with the passed in color
// Inputs:     ON  - turn all the pixels on
//             OFF - turn all the pixels off
void glcd_fillScreen(int color)
{
   int data;
   int *p1, *p2;
   int i;

   p1 = displayData.left;
   p2 = displayData.right;
   data = 0xFF * color;

   for(i=0; i<512; ++i)
   {
      *p1++ = data;
      *p2++ = data;
   }
}


// Purpose:    Write a byte of data to the specified chip
// Inputs:     1) chipSelect - which chip to write the data to
//             2) data - the byte of data to write
void glcd_writeByte(int side,int data)
{
   if(side)                   // Choose which side to write to
   	   high_CS2;
   else
	   high_CS1;		//CS1

   output_dato(data);
   high_Enable;
   wait_secons(2e-6);

   low_Enable;
   low_CS1;
   low_CS2;
}


//****************************************************************************//
// Purpose:       Write text on a graphic LCD                                 //
// Inputs:        (x,y) - The upper left coordinate of the first letter       //
//                textptr - A pointer to an array of text to display          //
//                size - The size of the text: 1 = 5x7, 2 = 10x14, ...        //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel()                                                //
//****************************************************************************//
void glcd_text57(int x, int y, char* textptr, int size, int color)
{
   int j, k, l, m;                       								// Contadores de bucle
   uint8 pixelData[5];                    								// Datos a imprimir

   for(; *textptr != '\0'; ++textptr, ++x)								// Bucle sobre las letras a escribir
   {
      if(*textptr < 'S') 												// Compruebo si estoy en el primer vector de letras
         memcpy(pixelData, FONT[*textptr - ' '],5);
      else if(*textptr <= '~') 											// Compruebo si salte al segundo vector de letras
         memcpy(pixelData, FONT2[*textptr - 'S'],5);
      else
         memcpy(pixelData, FONT[0], 5);   							 	// Definido para el espacio

      // cambio de linea y retorno de carro
      switch(*textptr)
      {
         case '\n':
            y += 7*size + 1;
            continue;
         case '\r':
            x = 0;
            continue;
      }

      if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping
      {
         x = 0;                           // Set x at far left position
         y += 7*size + 1;                 // Set y at next position down
      }
      for(j=0; j<5; ++j, x+=size)         // Loop through character byte data
      {
         for(k=0; k < 7; ++k)             // Loop through the vertical pixels
         {
            if(((pixelData[j] & (1<<k)) != 0)) // Check if the pixel should be set

            {
               for(l=0; l < size; ++l)    // These two loops change the
               {                          // character's size
                  for(m=0; m < size; ++m)
                  {
                     glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel
                  }
               }
            }
         }
      }
   }
}

//****************************************************************************//
// Purpose:       Draw a 3D box on a graphic LCD (Ex: to make a 3D Button)    //
// Inputs:        (x, y) - the start point                                    //
//                (width, height) - size of the box                           //
//                depth  - 3D depth effect ratio of the box (2 or 3 is fine)  //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel()                                                //
//****************************************************************************//
void glcd_3Dbox(int x,int y,int width, int height, int depth, int color)
{
   int i,j;
   for(i=x;i<=x+width;i++)
   {
      glcd_pixel(i,y,1);
      glcd_pixel(i,y+height,1);
   }
   for(i=y;i<=y+height;i++)
   {
      glcd_pixel(x,i,1);
      glcd_pixel(x+width,i,1);
   }
   for(j=1;j<=depth;j++)
   {
      for(i=y+j;i<=y+height+j;i++)
      {
         glcd_pixel(x-j,i,1);
      }
   }
   for(j=1;j<=depth;j++)
   {
      for(i=x-j;i<=(x-j+width);i++)
      {
         glcd_pixel(i,y+height+j,color);
      }
   }
}


//****************************************************************************//
// Purpose:       Draw a rectangle on a graphic LCD                           //
// Inputs:        (x1, y1) - the start coordinate                             //
//                (x2, y2) - the end coordinate                               //
//                fill  - YES or NO                                           //
//                color - ON or OFF                                           //
// Dependencies:  glcd_pixel(), glcd_line()                                   //
//****************************************************************************//
void glcd_rect(int x1, int y1, int x2, int y2, int fill, int color)
{
   if(fill)
   {
      int y, ymax;                          // Find the y min and max
      if(y1 < y2)
      {
         y = y1;
         ymax = y2;
      }
      else
      {
         y = y2;
         ymax = y1;
      }

      for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle
         glcd_line(x1, y, x2, y, color);
   }
   else
   {
      glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides
      glcd_line(x1, y2, x2, y2, color);
      glcd_line(x1, y1, x1, y2, color);
      glcd_line(x2, y1, x2, y2, color);
   }
}
//****************************************************************************//
// Purpose:       Draw less or equal 128x64 pixels of image to the graphic LCD//
//                screen on specified x, y coordinate                         //
// Inputs:        (x, y) - The start coordinate                               //
//                YES - Inverse of image (Raw data saved in ROM)              //
//                NO - Normal image (Raw data saved in ROM)                   //
// Dependencies:  glcd_pixel(), glcd_init()                                   //
//                                                                            //
//                       !!! PRLEASE BE CAREFULL !!                           //
//                                                                            //
//         First 2 bytes of your image data must be size of your BMP          //
//                                                                            //
// Example:       If your BMP image size is 64x32, first 2 bytes should       //
//                be 0x40, 0x20 --> (64 = 0x40, 32 = 0x20)                    //
//                                                                            //
//                      !! Check the "Bitmap.h" file !!                       //
//                                                                            //
//****************************************************************************//
/*
void glcd_image(int inverse)
{
   unsigned int i, j, k;
   unsigned int count=0;
   int width = 128;
   int height = 64;
   glcd_fillScreen(OFF);                        //Clears the screen (opt.)
   if(inverse==1)
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {

               if(!((image[count] & (1<<k)) != 0))
               {
                  glcd_pixel(j,i+k,ON);
               }

            }
            count++;
         }
      }
   }
   else
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {
            	if((image[count] & (1<<k)) != 0)
               {
                  glcd_pixel(j,i+k,ON);
               }

            }
            count++;
         }
      }
   }
}

void glcd_image1(int inverse)
{
   unsigned int i, j, k;
   unsigned int count=0;
   int width = 128;
   int height = 64;
   glcd_fillScreen(OFF);                        //Clears the screen (opt.)
   if(inverse==1)
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {

               if(!((image1[count] & (1<<k)) != 0))
               {
                  glcd_pixel(j,i+k,ON);
               }

            }
            count++;
         }
      }
   }
   else
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {
            	if((image1[count] & (1<<k)) != 0)
               {
                  glcd_pixel(j,i+k,ON);
               }

            }
            count++;
         }
      }
   }
}

*/

/*
void glcd_image_xy(int x, int y, int inverse)
{
   unsigned int i, j, k;
   unsigned int count=2;
   int width  = image_xy[0];
   int height = image_xy[1];
   glcd_fillScreen(OFF);                        //Clears the screen (opt.)
   if(inverse)
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {

               if(!((image_xy[count] & (1<<k)) != 0))
               {
                  glcd_pixel(x+j,y+i+k,ON);
               }
            }
            count++;
         }
      }
   }
   else
   {
      for(i=0;i<height;i+=8)
      {
         for(j=0;j<width;j++)
         {
            for(k=0;k<8;k++)
            {
               if(((image_xy[count] & (1<<k)) != 0))
               {
                  glcd_pixel(x+j,y+i+k,ON);
               }
            }
            count++;
         }
      }
   }
}
*/
/* USER CODE BEGIN (4) */
/* USER CODE END */
void wait_secons(float32 time)
{
	uint32 k_delay;

	k_delay=(uint32)(-3.6932+8.33333e6*time);		//Ecuacion para el Retardo, calculo fisico

    while(k_delay){k_delay--;};
}






